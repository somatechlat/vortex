// This file is @generated by prost-build.
/// Request worker to execute a job
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobRequest {
    /// Unique job identifier
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    /// Node type to execute (e.g., "com.vortex.ksampler")
    #[prost(string, tag = "2")]
    pub node_type: ::prost::alloc::string::String,
    /// JSON-encoded parameters
    #[prost(bytes = "vec", tag = "3")]
    pub params_json: ::prost::alloc::vec::Vec<u8>,
    /// Input tensor references (name -> TensorRef)
    #[prost(message, repeated, tag = "4")]
    pub inputs: ::prost::alloc::vec::Vec<TensorInput>,
    /// Output tensor specs (name -> dtype/shape hint)
    #[prost(message, repeated, tag = "5")]
    pub outputs: ::prost::alloc::vec::Vec<TensorOutputSpec>,
}
/// Tensor input reference
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorInput {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensor: ::core::option::Option<TensorRef>,
}
/// Reference to a tensor in shared memory
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorRef {
    /// Offset in SHM arena
    #[prost(uint64, tag = "1")]
    pub offset: u64,
    /// Total bytes
    #[prost(uint64, tag = "2")]
    pub size_bytes: u64,
    /// Data type (0=f32, 1=f16, 2=bf16, 3=i32, 4=i64, 5=u8)
    #[prost(uint32, tag = "3")]
    pub dtype: u32,
    /// Shape dimensions
    #[prost(uint32, repeated, tag = "4")]
    pub shape: ::prost::alloc::vec::Vec<u32>,
}
/// Expected output tensor specification
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorOutputSpec {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub dtype: u32,
    /// May be empty if unknown
    #[prost(uint32, repeated, tag = "3")]
    pub expected_shape: ::prost::alloc::vec::Vec<u32>,
}
/// Worker response after job completion
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobResult {
    /// Job ID (must match request)
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    /// Success or failure
    #[prost(bool, tag = "2")]
    pub success: bool,
    /// Output tensors (only if success=true)
    #[prost(message, repeated, tag = "3")]
    pub outputs: ::prost::alloc::vec::Vec<TensorOutput>,
    /// Error info (only if success=false)
    #[prost(message, optional, tag = "4")]
    pub error: ::core::option::Option<JobError>,
    /// Execution metrics
    #[prost(message, optional, tag = "5")]
    pub metrics: ::core::option::Option<JobMetrics>,
}
/// Output tensor from worker
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorOutput {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensor: ::core::option::Option<TensorRef>,
}
/// Job error details
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobError {
    /// Error code (VE-XXX)
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Human-readable message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Python traceback (if applicable)
    #[prost(string, tag = "3")]
    pub traceback: ::prost::alloc::string::String,
}
/// Execution metrics
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobMetrics {
    /// Execution time in microseconds
    #[prost(uint64, tag = "1")]
    pub execution_us: u64,
    /// Peak VRAM usage in bytes
    #[prost(uint64, tag = "2")]
    pub peak_vram_bytes: u64,
    /// Tokens processed (for text models)
    #[prost(uint32, tag = "3")]
    pub tokens_processed: u32,
}
/// Worker registration handshake
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHandshake {
    /// Protocol version
    #[prost(uint32, tag = "1")]
    pub protocol_version: u32,
    /// Worker slot ID
    #[prost(uint32, tag = "2")]
    pub slot_id: u32,
    /// Process ID
    #[prost(uint32, tag = "3")]
    pub pid: u32,
    /// GPU index (if applicable)
    #[prost(int32, tag = "4")]
    pub gpu_index: i32,
    /// Available VRAM in bytes
    #[prost(uint64, tag = "5")]
    pub available_vram: u64,
}
/// Host acknowledgment
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandshakeAck {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
    #[prost(string, tag = "2")]
    pub rejection_reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub shm_base_offset: u64,
}
/// Heartbeat (bidirectional)
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Heartbeat {
    #[prost(uint64, tag = "1")]
    pub timestamp_ms: u64,
    #[prost(uint32, tag = "2")]
    pub slot_id: u32,
    /// Current status
    #[prost(enumeration = "WorkerState", tag = "3")]
    pub state: i32,
    /// Current VRAM usage
    #[prost(uint64, tag = "4")]
    pub vram_used: u64,
}
/// Shutdown request
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {
    /// Grace period in milliseconds
    #[prost(uint32, tag = "1")]
    pub grace_period_ms: u32,
    /// Reason for shutdown
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Worker state enum
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerState {
    WorkerIdle = 0,
    WorkerBusy = 1,
    WorkerError = 2,
    WorkerShutdown = 3,
}
impl WorkerState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkerState::WorkerIdle => "WORKER_IDLE",
            WorkerState::WorkerBusy => "WORKER_BUSY",
            WorkerState::WorkerError => "WORKER_ERROR",
            WorkerState::WorkerShutdown => "WORKER_SHUTDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_IDLE" => Some(Self::WorkerIdle),
            "WORKER_BUSY" => Some(Self::WorkerBusy),
            "WORKER_ERROR" => Some(Self::WorkerError),
            "WORKER_SHUTDOWN" => Some(Self::WorkerShutdown),
            _ => None,
        }
    }
}
