// This file is @generated by prost-build.
/// Full worker status report
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerStatus {
    /// Slot ID
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    /// Process info
    #[prost(uint32, tag = "2")]
    pub pid: u32,
    #[prost(enumeration = "WorkerPhase", tag = "3")]
    pub phase: i32,
    /// Resource usage
    #[prost(message, optional, tag = "4")]
    pub resources: ::core::option::Option<ResourceUsage>,
    /// Current job (if any)
    #[prost(message, optional, tag = "5")]
    pub current_job: ::core::option::Option<CurrentJob>,
    /// Loaded executors
    #[prost(string, repeated, tag = "6")]
    pub loaded_executors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Loaded models in VRAM
    #[prost(message, repeated, tag = "7")]
    pub loaded_models: ::prost::alloc::vec::Vec<LoadedModel>,
}
/// Resource usage snapshot
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceUsage {
    /// VRAM
    #[prost(uint64, tag = "1")]
    pub vram_total: u64,
    #[prost(uint64, tag = "2")]
    pub vram_used: u64,
    #[prost(uint64, tag = "3")]
    pub vram_reserved: u64,
    /// System RAM
    #[prost(uint64, tag = "4")]
    pub ram_rss: u64,
    /// CPU usage (0-100%)
    #[prost(float, tag = "5")]
    pub cpu_percent: f32,
    /// GPU utilization (0-100%)
    #[prost(float, tag = "6")]
    pub gpu_percent: f32,
}
/// Currently executing job
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrentJob {
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub node_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub started_at_ms: u64,
    #[prost(float, tag = "4")]
    pub progress: f32,
    /// Human-readable phase
    #[prost(string, tag = "5")]
    pub phase: ::prost::alloc::string::String,
}
/// Loaded model info
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadedModel {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub vram_bytes: u64,
    #[prost(uint64, tag = "4")]
    pub loaded_at_ms: u64,
}
/// Register available executors
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutorRegistration {
    #[prost(message, repeated, tag = "1")]
    pub executors: ::prost::alloc::vec::Vec<ExecutorInfo>,
}
/// Executor information
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutorInfo {
    /// Node type this executor handles
    #[prost(string, tag = "1")]
    pub node_type: ::prost::alloc::string::String,
    /// Python module path
    #[prost(string, tag = "2")]
    pub module_path: ::prost::alloc::string::String,
    /// Class name
    #[prost(string, tag = "3")]
    pub class_name: ::prost::alloc::string::String,
    /// Capabilities
    #[prost(message, optional, tag = "4")]
    pub capabilities: ::core::option::Option<ExecutorCapabilities>,
}
/// Executor capabilities
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutorCapabilities {
    /// Supports GPU execution
    #[prost(bool, tag = "1")]
    pub gpu_enabled: bool,
    /// Supports half precision
    #[prost(bool, tag = "2")]
    pub fp16_enabled: bool,
    /// Supports batching
    #[prost(bool, tag = "3")]
    pub batching_enabled: bool,
    /// Maximum batch size
    #[prost(uint32, tag = "4")]
    pub max_batch_size: u32,
    /// Estimated VRAM per execution (bytes)
    #[prost(uint64, tag = "5")]
    pub estimated_vram: u64,
}
/// Request to load a model
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadModelRequest {
    #[prost(string, tag = "1")]
    pub model_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model_hash: ::prost::alloc::string::String,
    /// Load options
    #[prost(bool, tag = "3")]
    pub half_precision: bool,
    #[prost(int32, tag = "4")]
    pub gpu_index: i32,
    /// Priority (higher = more important to keep)
    #[prost(uint32, tag = "5")]
    pub priority: u32,
}
/// Model load result
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadModelResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    /// Memory info
    #[prost(uint64, tag = "3")]
    pub vram_used: u64,
    #[prost(uint64, tag = "4")]
    pub load_time_ms: u64,
}
/// Request to unload a model
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnloadModelRequest {
    #[prost(string, tag = "1")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model_hash: ::prost::alloc::string::String,
}
/// Security violation report
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityViolation {
    /// Worker that detected it
    #[prost(uint32, tag = "1")]
    pub slot_id: u32,
    /// Violation type
    #[prost(enumeration = "ViolationType", tag = "2")]
    pub r#type: i32,
    /// Details
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub call_stack: ::prost::alloc::string::String,
    /// Node that caused it
    #[prost(string, tag = "5")]
    pub node_type: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub job_id: ::prost::alloc::string::String,
}
/// Worker lifecycle phase
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerPhase {
    PhaseUnknown = 0,
    PhaseBooting = 1,
    PhaseIdle = 2,
    PhaseBusy = 3,
    PhaseDraining = 4,
    PhaseShutdown = 5,
    PhaseError = 6,
}
impl WorkerPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkerPhase::PhaseUnknown => "PHASE_UNKNOWN",
            WorkerPhase::PhaseBooting => "PHASE_BOOTING",
            WorkerPhase::PhaseIdle => "PHASE_IDLE",
            WorkerPhase::PhaseBusy => "PHASE_BUSY",
            WorkerPhase::PhaseDraining => "PHASE_DRAINING",
            WorkerPhase::PhaseShutdown => "PHASE_SHUTDOWN",
            WorkerPhase::PhaseError => "PHASE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PHASE_UNKNOWN" => Some(Self::PhaseUnknown),
            "PHASE_BOOTING" => Some(Self::PhaseBooting),
            "PHASE_IDLE" => Some(Self::PhaseIdle),
            "PHASE_BUSY" => Some(Self::PhaseBusy),
            "PHASE_DRAINING" => Some(Self::PhaseDraining),
            "PHASE_SHUTDOWN" => Some(Self::PhaseShutdown),
            "PHASE_ERROR" => Some(Self::PhaseError),
            _ => None,
        }
    }
}
/// Security violation types
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViolationType {
    ViolationUnknown = 0,
    ViolationBlockedImport = 1,
    ViolationBlockedSyscall = 2,
    ViolationFsAccess = 3,
    ViolationNetworkAccess = 4,
    ViolationExcessiveMemory = 5,
}
impl ViolationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ViolationType::ViolationUnknown => "VIOLATION_UNKNOWN",
            ViolationType::ViolationBlockedImport => "VIOLATION_BLOCKED_IMPORT",
            ViolationType::ViolationBlockedSyscall => "VIOLATION_BLOCKED_SYSCALL",
            ViolationType::ViolationFsAccess => "VIOLATION_FS_ACCESS",
            ViolationType::ViolationNetworkAccess => "VIOLATION_NETWORK_ACCESS",
            ViolationType::ViolationExcessiveMemory => "VIOLATION_EXCESSIVE_MEMORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIOLATION_UNKNOWN" => Some(Self::ViolationUnknown),
            "VIOLATION_BLOCKED_IMPORT" => Some(Self::ViolationBlockedImport),
            "VIOLATION_BLOCKED_SYSCALL" => Some(Self::ViolationBlockedSyscall),
            "VIOLATION_FS_ACCESS" => Some(Self::ViolationFsAccess),
            "VIOLATION_NETWORK_ACCESS" => Some(Self::ViolationNetworkAccess),
            "VIOLATION_EXCESSIVE_MEMORY" => Some(Self::ViolationExcessiveMemory),
            _ => None,
        }
    }
}
